<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC 架构模式示例</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }
      .controls {
        margin-bottom: 20px;
        padding: 15px;
        background: #f5f5f5;
        border-radius: 8px;
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        align-items: center;
      }
      .controls label {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .controls input, .controls select {
        padding: 8px;
        font-size: 14px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      button {
        padding: 10px 20px;
        font-size: 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        background: #007bff;
        color: white;
      }
      button:hover {
        background: #0056b3;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .status {
        margin-bottom: 20px;
        padding: 10px;
        background: #e3f2fd;
        border-radius: 4px;
        font-weight: bold;
      }
      .info-panel {
        margin-bottom: 20px;
        padding: 15px;
        background: #fff3cd;
        border-radius: 8px;
        border-left: 4px solid #ffc107;
      }
      .info-panel h3 {
        margin-top: 0;
      }
      .info-item {
        padding: 8px;
        margin: 5px 0;
        background: white;
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
      }
      .videos-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 20px;
      }
      video {
        width: 100%;
        border: 1px solid #ccc;
        border-radius: 8px;
        background: #000;
      }
      .architecture-badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
        margin-left: 10px;
      }
      .architecture-badge.mesh {
        background: #28a745;
        color: white;
      }
      .architecture-badge.sfu {
        background: #007bff;
        color: white;
      }
      .architecture-badge.auto {
        background: #ffc107;
        color: #333;
      }
    </style>
  </head>
  <body>
    <h1>WebRTC 架构模式示例</h1>

    <div class="info-panel">
      <h3>架构模式说明</h3>
      <ul>
        <li>
          <strong>Mesh（点对点）</strong>：所有客户端直接连接，适合小规模（&lt;
          10 人）
        </li>
        <li>
          <strong>SFU（选择性转发）</strong>：通过服务器转发，适合大规模（&gt;
          10 人）
        </li>
        <li><strong>Auto（自动切换）</strong>：根据房间人数自动选择最优架构</li>
      </ul>
    </div>

    <div class="controls">
      <label>
        信令服务器 URL:
        <input
          type="text"
          id="signalingUrl"
          value="http://localhost:3000"
          style="width: 250px"
        >
      </label>
      <label>
        房间 ID:
        <input type="text" id="roomId" value="arch-room" style="width: 150px">
      </label>
      <label>
        用户 ID:
        <input type="text" id="userId" value="user-" style="width: 150px">
      </label>
      <label>
        架构模式:
        <select id="architectureMode" style="width: 150px">
          <option value="auto">Auto（自动）</option>
          <option value="mesh">Mesh（点对点）</option>
          <option value="sfu">SFU（服务器转发）</option>
        </select>
      </label>
      <label>
        切换阈值:
        <input
          type="number"
          id="meshToSFUThreshold"
          value="10"
          min="2"
          max="50"
          style="width: 80px"
        >
      </label>
      <button type="button" id="connectBtn">连接</button>
      <button type="button" id="joinRoomBtn" disabled>加入房间</button>
      <button type="button" id="leaveRoomBtn" disabled>离开房间</button>
      <button type="button" id="disconnectBtn" disabled>断开连接</button>
    </div>

    <div class="status" id="status">未连接</div>

    <div class="info-panel">
      <h3>当前架构信息</h3>
      <div class="info-item">
        <span>配置的架构模式：</span>
        <span id="configuredMode">-</span>
      </div>
      <div class="info-item">
        <span>当前使用的架构：</span>
        <span id="currentMode">-</span>
      </div>
      <div class="info-item">
        <span>房间人数：</span>
        <span id="roomUserCount">0</span>
      </div>
      <div class="info-item">
        <span>切换阈值：</span>
        <span id="threshold">10</span>
      </div>
    </div>

    <div class="videos-container">
      <div>
        <h3>本地视频</h3>
        <video id="localVideo" autoplay muted playsinline></video>
      </div>
      <div>
        <h3>远程视频</h3>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
    </div>

    <script type="module">
      // 使用 esm.sh 提供的 npm 镜像（浏览器环境）
      import { RTCClient } from "https://esm.sh/@jsr/dreamer__webrtc@1.0.0-beta.1/es2022/client.bundle.mjs";

      const signalingUrlInput = document.getElementById("signalingUrl");
      const roomIdInput = document.getElementById("roomId");
      const userIdInput = document.getElementById("userId");
      const architectureModeSelect = document.getElementById(
        "architectureMode",
      );
      const meshToSFUThresholdInput = document.getElementById(
        "meshToSFUThreshold",
      );
      const connectBtn = document.getElementById("connectBtn");
      const joinRoomBtn = document.getElementById("joinRoomBtn");
      const leaveRoomBtn = document.getElementById("leaveRoomBtn");
      const disconnectBtn = document.getElementById("disconnectBtn");
      const statusDiv = document.getElementById("status");
      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");

      // 信息显示元素
      const configuredModeSpan = document.getElementById(
        "configuredMode",
      );
      const currentModeSpan = document.getElementById("currentMode");
      const roomUserCountSpan = document.getElementById(
        "roomUserCount",
      );
      const thresholdSpan = document.getElementById("threshold");

      let client = null;

      /**
       * 更新状态显示
       */
      function updateStatus(message) {
        statusDiv.textContent = message;
        console.log(message);
      }

      /**
       * 更新按钮状态
       */
      function updateButtons(connected, inRoom) {
        connectBtn.disabled = connected;
        joinRoomBtn.disabled = !connected || inRoom;
        leaveRoomBtn.disabled = !inRoom;
        disconnectBtn.disabled = !connected;
      }

      /**
       * 更新架构信息显示
       */
      function updateArchitectureInfo() {
        if (!client) {
          return;
        }

        // 获取当前架构模式（需要通过内部状态或事件来获取）
        // 这里假设可以通过某种方式获取
        const configuredMode = architectureModeSelect.value;
        configuredModeSpan.textContent = configuredMode.toUpperCase();
        configuredModeSpan.innerHTML =
          `${configuredMode.toUpperCase()} <span class="architecture-badge ${configuredMode}">${configuredMode}</span>`;

        // 更新阈值显示
        thresholdSpan.textContent = meshToSFUThresholdInput.value;

        // 注意：实际架构模式需要通过客户端内部状态获取
        // 这里仅作为示例，实际实现可能需要扩展客户端API
      }

      /**
       * 连接按钮事件
       */
      connectBtn.addEventListener("click", async () => {
        try {
          const signalingUrl = signalingUrlInput.value;
          const architectureMode = architectureModeSelect.value;
          const meshToSFUThreshold = parseInt(
            meshToSFUThresholdInput.value,
            10,
          );

          updateStatus("正在连接...");

          // 创建客户端，配置架构模式
          const options = {
            signalingUrl,
            autoConnect: true,
            architectureMode,
            meshToSFUThreshold,
          };

          // 如果是 SFU 模式，需要配置 SFU 服务器（示例中暂不配置）
          if (architectureMode === "sfu") {
            updateStatus("注意：SFU 模式需要配置 SFU 服务器地址");
          }

          client = new RTCClient(options);

          // 监听连接状态
          client.on("connection-state-change", (state) => {
            updateStatus(`连接状态: ${state}`);
            updateButtons(state === "connected", false);
          });

          // 监听 ICE 连接状态
          client.on("ice-connection-state-change", (state) => {
            updateStatus(`ICE 连接状态: ${state}`);
          });

          // 监听用户加入/离开（用于 Auto 模式自动切换）
          client.on("user-joined", (data) => {
            const userId = data.userId;
            updateStatus(`用户 ${userId} 加入了房间`);
            // 更新房间人数（需要通过客户端API获取）
            updateArchitectureInfo();
          });

          client.on("user-left", (data) => {
            const userId = data.userId;
            updateStatus(`用户 ${userId} 离开了房间`);
            updateArchitectureInfo();
          });

          // 监听媒体流
          client.on("stream", (stream) => {
            const localStream = client.getLocalStream();
            if (stream.id === localStream?.id) {
              localVideo.srcObject = stream;
              updateStatus("本地媒体流已设置");
            } else {
              remoteVideo.srcObject = stream;
              updateStatus("远程媒体流已设置");
            }
          });

          // 监听错误
          client.on("error", (error) => {
            updateStatus(`错误: ${error.message}`);
            console.error("WebRTC 错误:", error);
          });

          updateStatus("客户端已创建，等待连接...");
          updateArchitectureInfo();
        } catch (error) {
          updateStatus(`连接失败: ${error.message}`);
          console.error("连接错误:", error);
        }
      });

      /**
       * 加入房间按钮事件
       */
      joinRoomBtn.addEventListener("click", async () => {
        try {
          const roomId = roomIdInput.value;
          let userId = userIdInput.value;

          // 如果用户ID为空，生成一个随机ID
          if (!userId || userId === "user-") {
            userId = `user-${Math.random().toString(36).substr(2, 9)}`;
            userIdInput.value = userId;
          }

          updateStatus(`正在加入房间 ${roomId}...`);

          // 获取本地媒体流
          await client.getUserMedia({ video: true, audio: true });

          // 加入房间
          await client.joinRoom(roomId, userId);
          updateStatus(`已加入房间 ${roomId}，用户ID: ${userId}`);
          updateButtons(true, true);

          // 更新架构信息
          updateArchitectureInfo();
        } catch (error) {
          updateStatus(`加入房间失败: ${error.message}`);
          console.error("加入房间错误:", error);
        }
      });

      /**
       * 离开房间按钮事件
       */
      leaveRoomBtn.addEventListener("click", async () => {
        try {
          await client.leaveRoom();
          updateStatus("已离开房间");
          updateButtons(true, false);
          roomUserCountSpan.textContent = "0";
        } catch (error) {
          updateStatus(`离开房间失败: ${error.message}`);
          console.error("离开房间错误:", error);
        }
      });

      /**
       * 断开连接按钮事件
       */
      disconnectBtn.addEventListener("click", async () => {
        try {
          await client.disconnect();
          updateStatus("已断开连接");
          updateButtons(false, false);
          localVideo.srcObject = null;
          remoteVideo.srcObject = null;
          client = null;
          configuredModeSpan.textContent = "-";
          currentModeSpan.textContent = "-";
          roomUserCountSpan.textContent = "0";
        } catch (error) {
          updateStatus(`断开连接失败: ${error.message}`);
          console.error("断开连接错误:", error);
        }
      });

      // 初始化按钮状态
      updateButtons(false, false);
    </script>
  </body>
</html>
